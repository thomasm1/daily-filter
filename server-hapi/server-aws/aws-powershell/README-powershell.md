Introduction
Hi, my names Robert Cain. Welcome to Beginning PowerShell. In this video, we'll look at Microsoft's command line tool, PowerShell. We'll learn a little history of PowerShell and see some the various interfaces for working with PowerShell. We'll learn a few basic commands and see how pipelines can be used to quickly build powerful actions. PowerShell is known as a command line interface. Command line interfaces date back many, many years. In ancient times, the 1970's and 1980's, personal computers were command line driven. One of the most popular and what eventually took over the 1980's market, was Microsoft's Disk Operating System or DOS. When Windows was first introduced, it was an add-on on top of DOS, which relied heavily on DOS for its basic functionality. Even when the Windows 9x family was released, they relied heavily on a form of DOS for their core. Even though we have transcended that today, the command line interface lives on in the form of a command window or CMD for short. CMD will let you work with your computer using a command line interface. Sadly, CMD isn't much more powerful than it's ancestor DOS. If you want to write scripts, you're still stuck with the antiquated batch language recognized by the. bat extension on files. Clearly, CMD was long overdue for a replacement. Microsoft didn't have a really good base for creating a powerful new command line interface until. NET came along. PowerShell is based from the ground up and. NET. Everything is some types of a. NET object. If was originally introduced in 2003 under the code name Monad, but not released as Version 1 until 2006 and was an optional download. Version 2 however, is built right into Windows 7 and Windows Server 2008R2. It's also included as part of Windows XP service pack 3, Windows Server 2003 Service Pack 2, and Vista Service Pack 1. Commands in PowerShell are in the form of cmdlets, abbreviated as cmdlets. These cmdlets have a version/noun syntax. Some common examples are Get-Help, Get-Command, Set-Location, and Get-Alias. Some of the most common verbs you'll see are Get, Set, Out, Start, Stop, Restart, and Add. And some of the more common nouns you'll see are Help, Command, Service, Computer, Location, and ChildItems. Knowing some of these common nouns and verbs will make it easier as you learn new cmdlets. Okay, enough of the basics, let's start looking at some demos.

Basics of PowerShell
In the opening, I mentioned the old command line interface that's still built into various Windows products, such as this Windows 7. I just thought it might be nice to take a quick look at it, so we'll go to the Start, All Programs we'll come up here to Accessories, and you'll see here, Command Prompt. When I click on it, I get my Command Prompt window open. I can also get to it by clicking and in Search type in cmd and that's where it's the cmd name from as that's the command that's used to run it. If I come up here, it supports a lot of the old basic commands and if you don't remember any of these, there's things dir would bring up a directory of what you have, cls would clear the screen, cd would change you to another directory it stood for change directory, and if you see here I also have an old batch file in here that myps. bat. So if type in type myps. bat, you can see here I have a fairly simple little file that will change me over to the C drive by typing in c:. It changes directories and then displays the list of files in that directory. So I just type in myps and run it, I'm switched over to my intradirectory. So pretty simple and straightforward. The batch language isn't very complete, there's only some very basic things you can do with it, so it's kind of limited on what you can handle. Mostly what you wound up doing was writing custom applications to do the things you wanted, and then you just had the batch application call those custom apps. So we're going to Exit out of here and then we're going to take a look at PowerShell.

Customizing the PowerShell interfaces
Next, let's take a look at PowerShell itself and launch a PowerShell window. So we're going to click on the Start menu, we'll go to All Programs, we'll come up here to Accessories, and we'll come down here to Windows PowerShell, and then you can see I have a couple of options. I have a PowerShell x86 shell for doing the old x86 command based stuff. I then have a standard Windows PowerShell, which is 64 bit based, and then I have these two ISE's which I'll explain in a little bit. So we'll just click on the Windows PowerShell. and it opens us up a window that is somewhat reminiscence of the command window you just saw. However, it's got a lot more power and flexibility. Before I start showing you that though, there's some customizations that you're going to want to do to make PowerShell easier to work with. If I come up here to the Menu and I go to Properties there's a few things I'm going to want to tweak. First of all, I probably want my screen buffer to be a little bit wider than 80 characters. I typically set mine to 120, then on the Height of the buffer, you want to set that to a very high number. A lot of the PowerShell commands can be extremely robust, it can dump you a lot of information out. If you want to be able to keep track of that information and scroll back up to it, you want to make your buffer size really tall, so I usually start out with mine as 3000 and if that's not enough, then I can go back and increase it later. The Windows Size I also set to 120, the Height however can be variable because it's what's really important is that buffer and you can easily change the height once it's on the screen. So for the shortcut you can typically leave that at just 50 and then you can adjust it if you need to. Some other things you might want to do is change the Font from the standard Raster base font to one of the other Consolas or Lucida Console fixed based fonts or you may want to change the Colors. So let's click OK and you can see, I've now got this quite a bit wider. Another thing you can do is create shortcuts and have different settings for your various shortcuts. For example, let's close this and we'll come here, and we'll just go back to the All Programs, Accessories, PowerShell and we'll right click, do a Send to and we can send this to the Desktop as a shortcut. As you can see up here, I have three shortcuts setup for PowerShell. I have them labeled as Blue, Green, and Amber and when I open them up you can see here, I have an Amber looking screen. If I come in here to the properties you can see I've changed the font to Consolas and a 14 point Size. I also have a Green setup here, and in the Green one, I'm actually using the Green foreground color and Lucida Console as the font. Finally, I have something that'll hearken a lot of people back to the old days of DOS and I have the Blue with the White Raster font setup. Now, you may think that this is just kind of a nice example kind of thing, but I actually find it extremely useful to have different shortcut setup with different color schemes and fonts. Often, when I want to run multiple scripts at the same time, it can be handy to have the different colored windows that I can easily identify which script it running in which window. Okay, let's close some of these and then we'll launch just one of them, and we'll take a look at a few basic commands.

How aliases make PowerShell easy to learn and use.
Here you can see I've opened up my Blue PowerShell window and a lot of the old DOS based commands still work. For example I can do a cd and we'll go to our scripts directory, ps\01 - intro and whenever we have a path name that has spaces in it, we do need to include those inside of quotation marks. So there I am and I can do a dir and you can see what's out there. I can Copy files, copy Excel. txt a. txt and I can get my directory again. I can even clear the screen if I want to, cls, but what's interesting is, not only do DOS based commands work, but a lot of say Linux or Unix based commands might work. So if I do an ls, I get a listing. If I want to Copy a file and can do a cp and we'll copy x. txt to b. txt this time and we'll get another listing and you can see all the files are there and I'm actually using Linux based or Unix based commands to move around. Now these commands don't' really exist within PowerShell, instead Microsoft uses a concept called aliasing. They wanted to make PowerShell easy to use for people who are transitioning over from both say the Windows Server Admin people, Linux or Unix based people, and other folks. By using aliasing, Microsoft made it easy for a lot of commands such as dir or ls to be mapped onto the specific PowerShell commands. We can find the list of aliases available to use by using the get-alias cmdlet. Here you can see we've got quite a long list available to us and let me scroll up some and here you're going to see dir maps to Get-ChildItem. If I scroll down a little bit, we'll find the ls command, which also maps to Get-ChildItem. So coming down here, a dir and an ls and a Get-ChildItem cmdlet, should all give use the exact same results because they're all really the exact same command. Now, if you come from a history of another operating system and you're trying to learn PowerShell and you want to use some commands that are standard to you, you can actually set your own aliases. For example, let's say you would like to have a command called list. Well, there is no list command built into PowerShell. So you can actually do a set-alias, you'll give it the name that you want to create and then we'll give it the actual command you want to execute, Get-ChildItem. So now when I type list, there it is, it actually works for me. Be aware though, the lifetime of a list is only good as long as this PowerShell window is open. If I actually close it and then I reopen it and type in list, it's not there. I would actually have to go recreate it (typing) and we'll do it again, and there I actually have list. It is possible to save your aliases out to a file and the reload them. So for example, I could use the export-alias command and the name you want to give it is c:\ps\myalias. we'll use csv because it does become a separated value file and then I can actually specify the alias I want to save. I can do so by using wildcards or I can actually just give it the individual command. Now, when I exit out of here and I reopen it I can then do a list, which of course won't be here, but now if I do an import-alias c:\ps\myalias. csv and now I type in list, low and behold it's there. I can actually include a whole bunch of aliases within this csv file and then just load them whenever I want to. Okay, let's look at some more commands that are going to be useful to us. So far, we've been doing everything in these DOS based like command windows, but you can see that this might get kind of clergies after awhile if you wanted to start writing own scripts because there's no good debugging tools built into it. You have to jump to a separate editor to actually edit anything and overall, it's just not a very pleasant experience. Microsoft knew that and they actually created something for version 2 of PowerShell called the integrated scripted environment. So I go back the to the Start, All Programs, Accessories, I'll come down here to Windows PowerShell and here's our Integrated Scripting environment. Now this is the default layout for it and up here at the top you can see where we can edit scripts out. In the middle section is our results pane. This is where wherever we execute either a script or whenever we type in something from the immediate window down here, I could type in dir or I can type in Get-ChildItem and you can see they both print out here. You can see there is some wrapping going on because of the file sizes and limitations of the screen window, but you get the idea. Now, personally, I really don't like having my output window right in the middle of the screen, I kind of like it at the very bottom, it makes it easier for my eyes to always know to look at the bottom. So the first thing I do is usually move it down to the bottom and I did so using this little toggle button here. If you know you're going to work more in interactive mode than in script mode, you can actually hide the script pane by clicking that button there and now you just have interactive mode you and get a little more space for your commands and there you go. You can also change the layout for example, if you come to these buttons here, you can actually move your script pane over to the right, you can maximize it, or you can come back over here to the default view. Some of the other items are pretty standard. You can see we have built in debugging support, which we'll get into later. We can go View the different items such as the Script pane, the Command pane, and so forth. We can hit the standard --- editing function capabilities, we can Open files, Save them, Open up a New PowerShell Tab, so that we can have multiple tabs open, and the usual assortment of things that you would expect after a Microsoft product. Okay, that gives a little overview of the Integrated Scripting environment, let's actually use it to start taking a look at some basic commands available to us.

Basic PowerShell commands.
For this next section, I've loaded a script into the ISE and we'll use this to illustrate some of the more common commands you're going to want to get to know right away. I could choose to run the entire script by coming here and clicking on the Run Script button, but I actually want to execute only pieces of this at a time. To do so, I can highlight this and then I can either click the Run Selection button or I hit the F8 key. The first command that I just executed is Get-Command. As you can see here, I have a list of all the available cmdlets that are currently loaded into my PowerShell environment. I say currently loaded because it is possible to load up what are called providers and these providers will extend the list of cmdlets that you have available to you. As you can see though, out of the box, the list is pretty rich. We can also narrow down the get-command by passing in parameters. For example, I can do a get-command that shows me all the cmdlets that have the verb get and here you can see in my output window things like Get-PSDrive, Get-Provider, Get-Random, Get-Service, that kind of thing. I can also choose to look for only nouns. For example, I can find all the nouns that have the word service in them and you can see there's just a handful, Get-Service, New-Service, Restart, and so forth. The next command you're going to want to get to know is Get-Help. Get-Help will show you details about a particular cmdlet. So if I highlight this, you can see here I've asked for help on the Get-Command and you can see I've got the NAME of the command, a SYNOPSIS, a very short description about it. I've got the basic SYNTAX for using it. I've got a DESCRIPTION, which gives you a brief overview and I have some RELATED LINKS. For example, Get-Help, Get-PSDrive, Get-Member, Import-PSSession and so forth, you might want to look at as part of what Get-Help can do. It then tells us if we want to see more, we can go to get-help Get-Command -examples. I can use -detailed to get more info and I can really get down and dirty and go into the -full, so let's see what those output for us. We'll do the examples and you can see down here, you've got 11 different examples of how to use the Get-Command. We can go further and we'll do details, and here we are with more detailed information and the -detailed also includes the list of examples. Finally, we can go the -full and here we are with the output for -full. Okay, so, the last thing I want to show you about getting help is many of the commands support a -? parameter for getting more information. So if I do a Get-Command-? I get the same help that I would if I were to say, Get-Help Get-Command. So often times using the -? can be a nice shortcut to finding out more information about a particular command. Between Get-Command and Get-Help, you can learn an awful lot about what is available in PowerShell. Get-Help and Get-Command are going to be your two best friends as you start leaning the PowerShell structure. Let's look at a few other items so that we can kind of see how to build on what PowerShell gives us. Earlier we showed out dir was equivalent to a Get-ChildItem and there I have my output down below. Another thing you can do is change the current path. So for example, I can come and do a Set-Location and it changes my folder to C:\projects. I can do it again and this time it's going to take me to my SQL Server Presentations folder. The real power of PowerShell comes in when you start using a concept called pipelining. In pipelining, you combine cmdlets to produce the output you need. For example, I want to combine the Get-ChildItem, I want to take that output and pipe it through another cmdlet called where-object, but where-object will do is filter the output. In this case, I'm going to filter for files whose length is gt 100kb. So let me show you that and you can see now instead of having all those items I now have just a handful of files whose length is gt than 100kb. We'll talk about this more in depth in a later module, but just to give you a brief explanation, the. link command comes from the standard. NET library and it just says, give me the length of the current object. The $_ represents whatever the current object is. So what where-object is going to do is it's going to loop through every single file coming in from Get-ChildItem and each file will be represented by the $_. We'll then check the length property for each one of these files, and we'll look for files that are gt than a 100kb in size. Now you may notice the -gt, most languages use < > and so forth to do comparisons. PowerShell however, uses a lot of those things for the pipelining and the commands and what not, so what they chose to do was to make it simple and they use things like -gt for greater than, -lt for less than, -eq for equals and so forth and we'll see more of those when we get to the programming section of this series. The last thing to note is there is a concept that we can use to denote sizes in terms of not only kb, but also megabytes and gigabytes. You would simply use an mb for megabytes or a gb for gigabytes within PowerShell. It's the only language that I know of that has this nice shortcut built into it. Okay, let's build on this and we're going to come down here and now we're going to add to our command by tacking on a sort-object. What this is going to do is for each output in the where-object, it's going to sort that based upon the length. So I'm going to highlight that Run it and now if you look at the window down below, you can see that we have the same files, but their now sorted from smallest to largest. Okay, let's come back here. Sometimes these commands can get a bit long when we start pipelining them from one command to another. There's no requirement though that they all actually be on a single line. If I come down here, you can see I've taken the same command and broken it onto three lines, Get-ChildItem, Where-Object, and Sort-Object. The only requirement is that the pipeline character must be the last character on a line. So now when I highlight this and Run it, you can see I get the same results, but the command is now much more readable because it's sorted out over several lines. We can do a little more with this and format out output. We can take the output from Sort-Object and yet again pass it to something else called Format-Table. In Format-Table, we indicate the two properties we want to appear, the Name and the Length, and we've told it to AutoSize the columns. So now when I come down here and I Run that, you can see now I get the Name and the Length, they've been formatted to take up just as much space as they need, and everything's sorted correctly. There's one last command we'll take a quick look at and that is the Select-Object. Select-Object will allow us to only pull certain columns out of our output. So for example, if I wanted to get just the name and the length, I can do that off the Get-ChildItem and you can see now in the output below, I've just returned the Name and the Length for each particular item. The items you see that don't have a length are folders.

PowerShell Providers
Throughout this video, we've been using our local file system as a way to examine the capabilities of PowerShell. You may have wondered though, why are we using such weirdly name cmdlets to do so? For example, why set location to change our directories or why Get-ChildItem to list all the files and folders? PowerShell uses the concept of providers. A provider is a. NET library that provides a standard interface through which we navigate through whatever object that provider represents. By using the generic concept of providers, we can navigate through any type of object using the same commands that we're comfortable with. The Get-PSProvider command shows us a list of all the providers we currently have loaded in our environment. Looking at this list, you can see we have providers such as WSMan, Alias, Environment, FileSystem and so forth. Each one of these providers reveals itself to use in the form of Drives. It is through these Drives that we can navigate and retrieve data. If I come down here and runt the Get-PSDrive command, on the left it shows use the name of the Drive Alias, C, cert and so forth and in the middle it shows us which Provider is giving us that Drive. Let's use the environment provider to take a look at our environment variables. To do so, all I have to do is come down here to our env drive. We'll do a clear host to clear the screen, we'll set the location to the environment drive, and then we'll use Get-ChildItem to find all of those environment variables and there we go. Down here in the bottom, you can see a list of all the environment variables that I currently have. We can use commands like you've seen before to say from the table. Everything we've been doing will continue to work. We can also examine our list of PowerShell aliases through its drive provider. If I set my location to alias, you can see here through the alias provider I get a list of all the current aliases on my current PowerShell environment. We're not limited to using just the providers that are built into PowerShell, we can add new providers. We add new providers through a concept called snap-ins. Let's take a look at what snap-ins we currently have loaded. Our Get-PSSnapin cmdlet show us our list of currently loaded snap-ins, but we can also have access to snap-ins that are registered but not currently loaded. When I run it with the -Registered flag, you can see I have three snap-ins that are not currently loaded into my PowerShell environment. You'll see we have two of them for the SQL Server, let's load those up and examine some of its capabilities. To do so we'll simply use the Add-PSSnapin command and I'm going to add both of these at once and it doesn't give us any real feedback on the screen, but we can use the Get-PSSnapin command again and this time we'll use a name filter and we'll just get those that start with Sql and sure enough now, get PSSnapins telling us that these are loaded. So we can come down here and let's say that the Drive is loaded and if we look down here we can see we actually have a drive called SQL Server now. So let's navigate to the SQL Server Drive by using the Set-Location command and this time we'll set our location to SQL Server and we'll get our list of ChildItems. You can see it returned to us a pretty good list of stuff. We can use the PSChildName to get the data we really need and you can see now I've got a handful of children. I have SQL, SQLPolicy, SQLRegistration, DataCollection, Utility and DAC. The one we're really interested in is SQL because that's the engine that controls SQL Server. So let's go down here and let's say the location to SQL and we can see it returns us a list of our servers. This list is provided in the PSChildName and you can see there's the name for my local server which is just the name of my local computer, so let's go navigate to it and then we'll see what objects are available on my local server. Well, you see one the DEFAULT. That's actually a list of my instances of SQL Server I have and I only have one, which is the DEFAULT instance. So let's change to that instance and we'll Set-Location to it and we'll see what items are available there. Well as you can see we have things like Audits, BackupDevices, Databases, and so forth, all the things you would expect to be in a SQL Server instance. If I scroll down, we can actually go to our Databases by using Set-Location to Databases and we'll drill down into it and get a list of the databases that are available and here you can see is a list of all the databases I have and let's take a look at one of the AdventureWorks one, we'll use one of the lites, since that's a fairly small number of tables and we'll just come down here, we'll come here and we'll set the Location to that database and then we'll see what's there and then you have all the top-level items you'd expect to see in a database, Tables, SymmerticKeys, StoredProcedures, and so forth. Let's go see what tables are in and again we're going to do a Set-Location to Table and we're going to get the ChildItems and we're only going to pull out the PSChildName and there we go. There's a list of all the tables that are available to us in that particular database on our particular SQL Server. So you can see using providers allows us to add a lot of good functionality into PowerShell. When we're done, we should remove any snap-ins we're not using. So we can come down here and the opposite of AddPSSnapin is RemovePSSnapin, so we'll just run these Remove and there we go, and now let's validate that their not there anymore. We'll run the Get-PSSnapin and only get the Names and sure enough that is no longer loaded and we can get our list of providers, and we can see the SQL Server Provider is no longer listed. Clearly Microsoft put a lot of thought into the provider model. Using providers allows developers to become productive very quickly because they can use the commands they're familiar with to work with inside new environments.

dotNet in PowerShell, Summary
As we wrap this up, I'd like to show you one last thing. I mentioned earlier that this was all based upon. NET. If I use a variable called $a I can now assign that variable the value of I am not a PowerShell expert. All variables within PowerShell begin with the $. If I now print the value in a, you can see it comes out as, I am now a PowerShell expert. One of the most common properties of a variable is its length. I can do a $a. Length and I get 28. I can also execute the Get-Type method for our variable and you can see that it comes back as a string. In our next video, we'll look more at variables and how they work and we'll build upon the knowledge we've already learned. This video provided a good overview of the PowerShell world. You learned a little about its history, then saw the Microsoft provided interfaces for using PowerShell. We demonstrated using traditional DOS commands inside PowerShell and learned how the aliases made them work. We introduced you to Get-Help and Get-Command, your best friends for learning PowerShell. Finally, we took a look at how pipelining can be used to quickly build some powerful scripts. Thanks for watching.

PowerShell Variables
Introduction
Greetings, my name is Robert Cain. Welcome to Variables in PowerShell. In this video, we'll be going in depth with PowerShell variables. We'll start with a basic overview, then look at the cmdlets PowerShell uses for variables. The string variable type is quite powerful, so we'll have a detailed discussion on it. Arrays are also supported in PowerShell as are Hash Tables and we'll go over both of these before wrapping things up with a look at the Built in Variables. In PowerShell, all variables start with $. Here I have a variable called hi and I'm going to assign it the value Hello World. Now if I want to print out what's in that variable, I can simply put that variable name on a line by itself and there I have return Hello World. Now this is really just a little syntactic sugar. What PowerShell understands is that you actually meant to write this variable out to the host, so it shortcuts it by automatically filling in the Write-Host command for us. I could have actually just called the Write-Host cmdlet and passed in the name of the variable and I get the same results. It's important to understand that all variables within PowerShell indeed pretty much everything in PowerShell, is a. NET type of some kind. Here, if I call the GetType method on my variable, it tells me that it's a string, which makes sense because we put the value of Hello World into it. Unlike some languages, PowerShell has mutable variables. So I can reassign it the value 5 and when I run this, the type will now have changed to an integer and sure enough, I'm now holding an Int32 as a high variable, instead of a moment ago when I had a string. It is possible to declare your variables in a statically typed fashion. Here, I'm going to use the. NET type of System. Int32 to force my variable myint to be an integer. If I do a GetType, you can see I've printed out the value as 42 and it is indeed an int. The difference now is, if I try to assign a string into this integer it produces an error for me because I've statically typed this to be an Int32, it will not mutate into anything else. While I had to type in System. Int32, there are actually shortcuts within PowerShell for most of the. NET data types. Here you can see I'm using just the work Interested, which equates to an Int32. I also have the option of a string and several other data types including short, float, decimal, and so forth. It's important to realize that not just variables, but many things in PowerShell are. NET data types. Here I've just put the value of 42 and called its GetType and you can see it becomes an Int. I can do the same thing with a static string and it comes back as a string. Now that this means is, we can call any of the methods on a. NET string data type. For example, I can come down here and call the ToUpper method and you can see down in my output, I now have Pluralsight ROCKS in caps. I can also come here and I can see if it contains the word Pluralsight and it does return true, so we know it does. PowerShell handles it's comparisons in a slightly different manner that most programming languages. Here I'm going to assign a value of 42 into my variable. That done, I want to do some comparisons. Most languages use things like <, >, even the =, but PowerShell reserves these for special functions. Even the = used for doing assignments. So what does PowerShell use? Well, it adapted a syntax that somewhat reminds me of a URL when you're passing in values such as gt, lt, and so forth. It uses a -gt to do a greater than comparisons. If I compare the value 40 to what's in my variable, it tells me it's true because 42 is greater than 40. For the same token if I do a less than comparison, it returns false because 42 is not less than 40 and of course it use -eq for equals, and there's a whole list of them down here. We have Equals, Not Equal To, Less Than, Greater Than, Less than or equal to, or Greater than or equal to. We also have some comparisons for strings. We have Like, NotLike, Match, and NoMatch. Next, we'll take a look at calculations and there's not a whole lot to show here because calculations are pretty much like they are in any other language. For example, I can use the * to multiple 3 * 11 and return the value of 33. The other standard operators like +, -, and /, apply to do addition, subtraction, and division. PowerShell also supports the unary operators of ++ and --. If I take the value of var, which is 33 currently and I ++ it, I now get 34 on my output. Because of its typing system, you have to be careful of implicit type conversions within PowerShell. For example, if I compare the string 42 to the numeric 42, they come out -eq because PowerShell converts 42 from an Int to a String and likewise, when I do it this way, it'll convert from a String to an Int and come out true in comparison. The rule is, whatever is on the right side of the comparison operator is converted to the data type on the left. Now this can lead to some odd conversions when you're doing the comparisons. Let's take a look at this next line. It's going to take the string value of 042 and it's going to convert that to an integer, so it can compare it to the integer type of 42 over on the left. Well when it does so, the leading 0 goes away and you just wind up with the numeric value 42 and you're comparison comes out to be true. On the next line however, we're going to be converting the integer value 42 into a string. Well when it does so, the resulting string will be just "42" which will not compare equally to the 042 that's on the left and it's going to come back false. So just be careful when you're doing some of these conversion comparisons and don't trust too much on implicit type conversions.

Cmdlets
In our lesson on variables so far, you seen variable usage that's pretty much like any other language. If we want to assign the value of 33 to a variable, we simply say the variable = 33 and then we can print it back out. Text works very similarly. What you have to understand though is under the scenes, PowerShell is calling one of the five cmdlets for you. It's worth knowing about these variable cmdlets, so let's take a look at them. The first one is New-Variable. Through New-Variable, we assign the value of a variable. What you see here, New-Variable -Name var -Value 123, is the equivalent if saying $var=123 and we'll print it back out and you can see sure enough we have 123 now held in our variable. Note that for the variable cmdlets, you don't use the $ when you're passing them into the variable cmdlet. If we want to take a value out of the variable and display it, we can use Get-Variable, the variable name, and then pass in the parameter -valueonly. This will emulate what you saw above where we simply put $var. If we hadn't passed in the value of -valueonly, we would display both the name and the value in formatted output. If I want to see all the variable, both user defined and system defined, I can simply say Get-Variable and you can see here we get a list of all of our variables that are out here including our -var right there. We can also assign a new value to an existing variable. This is the equivalent of $var=789 instead we'll use Set-Variable -Name var -Value 789 and we'll print it out and there we go. Our existing variable now has a new value to it. So far, what you've seen is pretty easy to do using the existing variable commands that you know about. A couple of nifty things though you can do that you can't do normally through variables is you can clear the contents of a variable, the equivalent of setting it to a null value. So here, I'm going to use Clear-Variable -Name and it will clear the contents. Now if I display it, you can see it doesn't display anything. If I want to come back up here and use my Get-Variable command, you see it does display the variable, its still there, it just doesn't have anything in it. If however, I come down here and I use the Remove-Variable command, Remove-Variable completely obliterates that variable from memory. It no longer exists in the context of the current PowerShell environment. So when I Run this, now if I were to come try get the value, it would actually generate an error because that variable no longer exists. Not only will it produce the error for Get-Variable, it'll also do so for Clear-Variable or Remove-Variable. Note, if I had just tried to do a $var and run that, it actually works because the minute I do that it actually creates a new version of the variable. So be aware that if once you remove a variable if at any point you try to reference it again, that variable pops back into existence.

Strings
PowerShell is one of the most versatile languages for dealing with strings that I have ever seen. You can define strings using double quotation marks and single quotation marks. In order to embed quotes within another quote, we can mix them. Here, I want Hello World to be surrounded by double quotes so we'll embed them in a string defined by single quotes and we can see Hello World is properly quoted. The reverse holds true. Here I want can't to have a single quote, so I'll embed the whole string in double quotes and you can see my single quote comes through. If we don't want to mix quotes, we can use a technique called double quoting to embed quotes within other quotes. Here I have ""Hello World"" and can define the string with double quotation marks and here you can see Hello World come out correctly and the same holds true for the single quotes. I have '' for can't, and there it is. As with many languages, PowerShell allows you to embed special characters within the strings. These special characters are denoted using escape sequences. Escape sequences begin with a `, which is the little key next to number 1 on your keyboard and it's usually the un-shifted version of the little ~ squiggly character. Here, the backspace can be represented with a `b. Unfortunately, it doesn't show well within the shell, so we actually need to open up a PowerShell window and here you can see I've got plural`b and sight and when I hit enter, I actually get plurasight as my results. Another special character that's often used is the newline character. As you can see `n forces the remaining of the word on to a new line. Another one you'll see often is the carriage return. Now here, the carriage return doesn't show anything, but the character really is embedded within our string. Most common though, you'll actually combine these to form what's called a carriage return line feed, a character that's often embedded in text files. The tab is also supported as an escape sequence by using a `t and here we get Pluralsight. Now you may ask yourself, what if I want to embed a really, really long block of text within a string? For that, Here strings were invented. To define a here string, you declare your variable and at the end of the line you put an @ followed by a ". I then have some text, some more text, then a bit more text, and I can even insert blank lines. When I want to end my here string, I go down to the next line and I put the "@ to close it out. That syntax is very important. To start the here string, that @" must be the last character on a line and then everything starting on the next line and going all the way down is in the here string until it hits the "@ which must be the first characters on a line. If I were to put this at the end of the line here, it would not work. So let's watch this defined and we'll Run that, so we've got it defined and now, when I want to display it, I hit my here text output correctly. It also works using single quote defined strings. Here, I have some more here text, which I'm going to define and I'll run this and it's now defined and you'll notice that I the word let's in here I didn't need to use the double quotations. Here, I Run it and there go, you see that the let's is properly quoted with that single quote mark. So any quotation marks within the context of a here string are ignored. PowerShell also supports the concept of string interpolation. Simply put, this means that if PowerShell is evaluating a string and it finds the name of a variable within that string, it will replace the name of the variable with the value of the variable. Here, I've set my location to my PowerShell sample directory and then I've used variables to get the number of items in that folder, as well as returning its location. So I'll execute those and I now have those variable loaded. Now when I run this string, instead of displaying $items, it replaces that with an 11 and it replaces the $loc with my C:Pluralsight folder name. If I actually want to display the true variable name, I have to use a `, which is another escape sequence within my string and here you can see I do display $items and $loc. You should not that interpolation only works with the double quotes. Here, I've put my string in single quotes and it doesn't work. String interpolation does work with here strings. Here I'm defining a here string and within it, I have Items and then a tab and then my Folder, so I form a little header and then down below I have my variables and then finally I close up my here string with a "@. So we'll assign that and now when we actually go display it, I get my nicely formatted number of items and what folder there in. We can also use expressions within our strings, however, they need to be wrapped up with a $() in order for PowerShell to force the evaluation. So here, let's go ahead and clear the screen, and then I'm going to replace what I had before, the variable names, with the actual cmdlets that I needed to get that data. So here I have $() my Get-ChildItem cmdlet and I'm returning the count from it, and then likewise at the end of my string I have a Get-Location and then when we go I get the same results of 11 items in my folder. We can also use this to do calculations. Here I've got my $() and inside I have it calculating the 15% of $33. 33 and it returns me the result of 4. 9995. PowerShell also supports string formatting much like you find in many c based languages. We'll the string formatting you use a placeholder in the place of a variable and then at the end of the string, you pass in one or more variables you want to replace. Here, we're using the squiggly bracket 0 squiggly bracket as our place holder and we only have one item, the number of items. The string:: means I'm calling the static method format off of the string type within. NET and you can see I have 11 items. That PowerShell provides some nice shortcuts for us. I can simply put these are the placeholder of 0 items and then I can pass in a -f, which means this is a formatted string and I pass in the variable and there we go, I have 11 items. Now, if we have more than one variable we want format, we simply include those as additional placeholders within my string and we increment the number to indicate the placeholder. So, 0 is the first placeholder, 1 is the second and so forth. These correspond to the positions in which you pass the variables in. So, $items is the first one I pass in, therefore, it goes into the squiggly 0 and $loc goes into the squiggly 1. As before, this also works with calculations. Here I'm taking the 20% tip of $33. 33 and I'm going to replace it within my string and here I get that my tip is 6. 666 dollars. Now we may want to format that to make it a little more pleasing to the eye, so we can also provide additional formatting after the placeholder of 0, we place a : and then 0. 00, which is an indication we want 1 character to the left of the decimal and two to the right and here I get 6. 67 dollars. PowerShell also supports the use of wildcards when doing string comparisons. In order to do a string comparison you can use the like operator. So here, I have Pluralsight which I want to see if it's like Plural with an * at the end, * simply means any number of characters after the word Plural will result in a match, and sure enough, these do match. However, when I compare it to the word arcane with an *, it returns false because those aren't alike. PowerShell also supports the traditional? as a single character placeholder and here we can see it's true because it matches with any character being the first character. PowerShell also supports range matching. Here I'm comparing it to Plural than any number of characters of any type, and then last character of this string has to end in the range of s-v. Well because t is between s and v I get a true. However, when I run this, I get a false because t is not between a and c. PowerShell also supports the use of regular expressions in doing matching. Here I have a string of Pluralsight's phone number, and that really is Pluralsight's phone number, 888-368-1240 and it's going to match to see if it matches the pattern defined in the regular expression on the right. If you're not familiar with regular expressions, this very simple will take any character in the range of 0-9 and it expects three of them as defined by the squiggly braces. I then have a - which means it's just a literal character of a -. I then repeat it. The brackets indicate any number in a range of 0-9, three more and then repeat at the end with four. So when I run this, I get True because it does match that pattern. The second line does not match because zzz is not a character in the range of 0-9. Finally, you might think this last one will match, but it doesn't because a. is not the same thing as a -, hence I don't get a match.

Arrays.
Arrays in PowerShell are extremely simple and flexible. To assign an array, you can simply list all the items you want in there separated by commas. Here I've assigned a couple of values. If I want to get one those values out, I use a traditional indexing syntax where I pass in a number that indicates the position in the array within brackets. All arrays in PowerShell are 0 based. This means the very first element in the array will be at position 0 and here I've returned that and we'll do we'll do the second position, which is 1. If I want to display all of the values in my array, I simply Run that and I get everything. Let's go see what data type an array in. NET par once it is an object. Now the brackets after the object, indicate this is an array of objects. Array's are also easy to update. Here, I'm simply going to assign a whole new set of values to my array and I'll just plug my name in there, then when I display them, you can see their listed on each item. Now let's say I want to replace that with other values, say Plural for position 0, I can run that and I've now replaced it and if I go print the contents of the array, there you can see I've now replaced the first element and let's replace the second element and then we'll print it out, and there we go, there's our new array having been updated. There is a formal array creation syntax and that is to use an @ symbol followed by a ( the values and then another ). So here I'm going to assign these values and then print them out, and that worked fine. Now the reason I mention the formal creation syntax is because if you want to create an empty array for some reason then the only way you can do that is by using the formal array creation syntax, which is simply the @ symbol and then we'll just not put anything inside of our () to indicate that this is an empty array and if I want to display how many values in there, I get 0 indicating it's an empty array. Partial also has a cool shortcut syntax for loading an arrange of numeric values. It is to put the first value followed by two periods and then last value. So here, I'm going to load the values of 1-5 into this array variable and then we'll print it out and I get the values 1, 2, 3, 4, 5. Another common thing to do is to check to see if an item exists within our array. Here I'm going to an array called numbers and I'm going to load three values then into it, 1, 42, and 256. I then want to see if the number 42 exists in this array. Well to do that I use the -contains. After the contains I then simply pass in the value that I want see if exists and sure enough, 42 does exist as a value within our array. I can also check to see if values are not in the array by using the -notcontains. When I do so, I run it and it tells me sure enough 99 is not in my numbers array. Now using -notcontains can get kind of confusing sometimes because here, I'm going to check to see if a value, in this 42, is not in the array. When I run this, it tells me False, that this value is in the array. So the double negative syntax can get pretty confusing, for that reason, I suggest you stick to just using contains.

Hash Tables.
In addition to arrays, PowerShell has another method for holding lists of values called hash tables. In an array you use an index that is numerically based to go look up a particular position within the array and then return a value. With hash tables a string based key is used to go get the value for that particular key. Here you can see I'm defining a hash table by using the @ symbol followed by a squiggly brace. I'm defining three values for my hash table. The first is Key with a value of Value, then I have Pluralsight with Pluralsight. com as the value, and the Arcane Code with arcanecode. com for the value. I've separated these key value pairs with ;. So let's load this up, then let's go print out its value. You can see here I have my keys on the left and values on the right. Now if I want to return the value for a single key, I can enclose that within the brackets just as I would for an array, but instead of a number I'm going to pass in the key. So here, I'm returning Pluralsight's web address by passing in the Pluralsight key. I can also use an object type syntax to get to my values. So here, I'm using Pluralsight key after a. and I also get the same value back of Pluralsight. com. I can also use variables for my keys. So here you can see I'm assigning the value Pluralsight to a variable named mykey. I can use the object syntax and return the value. I can also enclose that expression and here I can actually have an expression which I'm defining as Plural + sight as a string and I am forcing it to be an expression by using my $ (), remember that from earlier in our string handling discussion, and there we go Pluralsight. com. Adding or removing values I pretty straightforward. Here, I'm going to display what's in there right now. There's my three keys and my three values. I'm now going to add a new value. To do so, I'm going to enclose that within brackets to have the new key and then I'm going to assign its value on the right. Now that I've assigned it, I can go retrieve it and now you can see I've added a new value to my key list pair for the $ hash table. To removing it, I simply use the remove command $hash. remove and I pass in the key I want to remove, and there I've just removed Arcane Code and I'll run this and now I get three new key values with the Arcane Code one removed. Seeing if a key exists is a pretty common thing, you'll often will want to see it before you add it or remove it for example. So to do that we simply use the contains method off the hash table. So here it should be there an sure enough it is and now let's see if the one I just removed is still there and it returns false because it's not. I can see if a value exists by using the ContainsValue method. So here, I'm going to see if the Pluralsight. com value is there and sure enough it is there within my hash table and then we'll see if this one's there and nope it's false because I did just remove it. I can also get a complete list of my keys and my values by simply calling the keys or the values method. Here I've called the keys and it lists all my keys and I'll use. hash. Values and there they are. I can also search to see if a key or value is already present within my hash table. You can see I can use the contains keyword. I pass -contains and then the name of the key I'm looking for to the. keys method for my $hash and sure enough it tells me it's there. I can also do the same thing with values. By passing -contains and the value I'm looking for into my. values method there it is, true enough it's there.

Built in PowerShell variables
In addition to being able to create your own variables, PowerShell has a list of built in variables. It's quite a long list, but we're just going to take a look at a couple of the more useful ones that we can start using right away. The first two are false and true. If I just print these out, you see I get a simple False or a simple True back. These are useful for doing comparisons to see if the result is some logical comparison comes out to be False or True. It makes it a lot clearer than using a 0 or a 1. There's also a placeholder for null. Of course it doesn't display anything to us, but again it can be used in doing comparisons. Another useful one is pwd, which prints out the current working directory and here we go I'm in my demos directory. I can also see what my home directory is. I can find out a lot of information about my particular PC, and it shows what version of the PowerShell I'm running, my InstanceId, my UI, things like that. I can also find out what the Process ID is for the interface that I'm currently running and there we go, right now it happens to be 2712. We can also find out information about the current version of PowerShell, there we go. Once of the most useful ones though is the variable that holds the current object. Here I'm piping Get-ChildItem through the Where-Object. Now what this is actually passing in is a collection. The $_ allows me to iterate through each item in the collection and points to the current item. So what's going to happen is Get-ChildItem is going to pass in its collection to Where-Object. Where-Object is going to iterate over my collection of ChildItems, which in this case are the files in my current folder and then for each one of those, I can retrieve the. name property off the current object and if it's like ps1 it's going to print it out. So there's just a few of the useful built in variables that PowerShell has and as we move through the lessons, we'll be taking a look at a few others as they become relevant.

Summary
By now, you should have a firm understanding of PowerShell variables. Your knowledge of the * variable cmdlets gives you a good insight into how PowerShell works with variables under the hood. You should know all about strings and the power they hold. You've mastered collections both in the form of arrays and hash tables. Finally, you saw a few of PowerShell's built in variables, which you can use to enhance your own applications. Thanks for watching.

PowerShell programming
Introduction and Branching
Hi, my name is Robert Cain and welcome to the Fundamentals of PowerShell Programming. In this video, we'll cover the Fundamentals of PowerShell Programming. If you're a developer many of these concepts will be familiar to you and it'll be easy to pick up the syntax. If not, don't worry, the concepts are quite easy to learn. We'll begin by looking at Branching, executing code based on a set of conditions. Then we'll look at Looping which will allow us to repeat a block of code. Speaking of blocks, we'll look at what a Script Block is and how to use them. Finally, we'll build on what we know about variables when we talk about Variable Scope. Most languages support the concept of branching. Branching is simply making an evaluation of some expression and then having certain blocks of code run depending upon the output of that condition. Here, I'm assigning the value of 2 to a variable and then I'm using one of the simplest branching constructs out there an if/else. The if statement will evaluate what is the in parentheses. in this case, does $var -eq 1? Within the parentheses I can put just about anything as long as the final result of this expression is either True or False. So $var -eq 1, in this case is going to be False, so it's going to fall down to the code inside the else. Otherwise if it has been True, it would have run the code here in the if statement. So let's go Run this and as you can see it prints out else branch. Many languages also have a construct called if/else/if, which is just a way of having extra else conditions in here. PowerShell does not have that, so what you have to do is next another if block down here in the else clause. So here, we're going to come here and Run this and now you see we're on the if -eq 2 branch. So, this failed, it gave me false, so it branched down here else and now it's going to do another evaluation and this time If -eq 2, so it's said hey we're good to go and we're going to execute the code inside here. Anytime you see code with squiggly braces around it, that's known as a script block. We saw how if statements are good for either if or else, one outcome or the other, but what if you have multiple things that you want to check for? We'll for those, you'd want to use a switch statement. Here, I'm going to assign the value of 42 to my variable and then I'm going to switch based on it. Well in the switch it'll first check for the value of 41, then it's going to check for the value of 42 and if it matches it's going to execute what in the script block, otherwise it's going to check to 43, check for default, and then exit. So let's go Run this and you can see it prints out Forty Two. If I come up here and we'll change this to say 43 and rerun it, I get the value of Forty Three out, and if I change it to some value that not's in there, say 49, and Run it, it'll hit the default branch and say default. Now when I said it will check for 41, then it will check for 42, then it will check for 43, I was being quite literal. Just because it found a match on 42 doesn't mean it stops checking. Here's a little example. Let's clear the screen and we're going to assign the value of 42 again and then we're going to come in here to the switch statement. Now when I Run this, you'll see I actually get both Forty Two and Forty Two String out of here. What's happened is PowerShell first compared the integer value of 42 to my integer variable, which also happened to have 42 in it, and it executed that script task and then it came down here and said okay, I now want to compare this. Well, this is a string 42, so PowerShell then converts that to an integer so it's comparing an integer value to the integer value in my variable and thus it found a match and I got the string out and of course, since it did matches above it did not execute the default code. Sometimes that can be pretty useful. You want to be able to check for multiple conditions and have --- the same code execute for various reasons, but what if you don't want that? How do we stop that? Well, we can come down here and we can use something called break and again we'll clear the host, and we're going to assign value 42 and this time, at the end of this first 42, I'm using a break command. So I have a ; and then a break. If you're in a script task and you want to have multiple commands, which are normally on individual lines, all bunched up on the same line, you use a ; to separate them. So here, we're going to switch in here and now, we're only going to get the string Forty Two and not the second one of Forty Two String. That's because it hit the break statement and exited out. Switch also works with collections. It will loop over the collection and execute the code for each item. So here we've got four items, a 3, a 1, a 2, and a 42 all separated by commas. Now I'm making this simple, this could also be an array you're passing in or a collection of objects. So here, I'm going to execute this code and there we go, I actually get Three because the first time through it found a match, then the second time through it found a match for One, third time through it found a match Two, and on the last item 42 it didn't find a match at all. It's important to note that comparisons are case insensitive by default. What this means is the case of the strings are ignored. Here, I'm going to compare a capital P, Pluralsight and I'm going to compare it to Pluralsight all in lowercase, all in uppercase, and in mixedcase and when I run this, I actually find matches for all three. If I don't want that, if I want my comparison to be case sensitive, I simply have to pass in a -casesensitive switch. So now, it will only find one match for mixedcase. The switch statement also supports wildcards. Here, I'm going to switch and this time I'm going to indicate that it's a wildcard search. So now, it's going to look for plural* and if the value I'm passing in matches that wildcard I'll get a result back. It also supports a single? or multiple? as character placeholders. So now when I run this, I'll actually get matches for all three of them and sure enough, I get my *, my?, and my??? back. Note too that the switch statement also supports regular expression matching.

PowerShell Looping
Looping is another fundamental construct of most programming languages. PowerShell supports a wide variety of looping features. The most basic is the while loop. Here, I have a while command and then I have a little script block below it. While the condition within the parentheses is true, it will execute the code within that little script block. So here, I'm going to set a variable to 1 and then I'm going to loop through my while loop and each time I'm going to increment the value of i by 1. So let's Run this and there we go, it simply listed those values 1, 2, 3, 4, 5. Interesting thing to note that the while loop won't execute if the condition is already true. So here, I have set the value of i = to 6. Well in a while loop, i -le or eq to 5, well obviously 6 is greater so there's no reason for this execute. So I'm going to run this just to show you and nothing happened. Now if I want to make sure that the loop executes at least once regardless of the value of the initializer, then I can come down here and use a dual while loop. In a do while loop I also have to set my variable i = 1 in this case. I have the word do and then I have my script block and you'll notice down here my check is at the very end of the loop, while($i -le 5). So let's come here and we'll Run this and you can see sure enough, I print out 1, 2, 3, 4, 5. Also note, in this case I've used the unary operator #i++ it's the same thing as $i -eq $i+1 just a little bit more compact syntax. I mentioned that the while loop is always get execute at least once when it's used in this do while structure. So here, I've set the value of i = 6. When I execute this, unlike the plain while loop, it executed at least once because it didn't do the check until the very end. Something else I'd like to point out about the while loop, if you look at their condition we're looping while a certain condition is true. So as long as $i le 5, it's going to execute the loop. Once that condition becomes false, it stops executing the loop. Now some people like to have the reverse logic, they want to execute until a condition is true. Well to handle that and to make our checking a little more positive, instead of the dual while, we can use the do until. So here you can see I set $i = 1 and then I'm going to do until($i -gt 5). So let's highlight this so we can run it and there we go 1, 2, 3, 4, 5. So as long as our condition is false, i was less than 5, it executed the loop. Once that condition was true that is when the loop stopped executing. Now, the do while, do until, and while are great for iterating while you're looking for a certain condition, but what if you just want to loop over a set number of times? Well for that, we have a for loop. Here in the for loop, we're going to execute this script block, right there, while these conditions here within the for our set. Now this first item you see is the initializer and the initializer you take a variable and you set it = to some value you want to start to counting from. So in this case, we're going to start counting from 0. The next thing is our condition that we want to stop on. So in this case, we're going to execute while $f -le 5. Then after the ending ;, you've got our incrementer and the incrementer tells us how many to increment out variable by each time through the for loop. So here, we're going to increment this by because I'm using $f++ and that's the traditional way to do things, however, you maybe increment by 10, 20, 100 whatever works for you. So we could have easily said $f+100, so any of these would have worked. So we're going to come here, we're just going to execute this and there we go 0, 1, 2, 3, 4, 5. Now, notice that we can set the initializer separately. So here I've set f = 2. When I want to set the initializer outside the loop, I simply leave the initializer section of my for block empty. So here, when I run this, you can see I get 2 because that's what it started with 3, 4, 5. You can also use a for, to loop over a collection. If you recall from our discussion on variables, we can address individual items within an array or in a collection by using a left bracket and then a variable that points to the position inside the array. So here my array is $array and then $i is going to represent the pointer into the array for the item I want. So here I've setup a simple array and I want to pull the values of 11, 12, 13, 14, and 15. In my for loop, I'm going to start counting with 0 and then I'm going to go while $i -lt the length or the array then I want to increment my 1 each time through. Now in case in case you're wondering why I'm not going to less than or equal to, well let me show. Here let's load up the value of the array. Let's actually go find out how many items are in the array and sure enough we have 5 items, but the pointers actually start at 0. So even though I 5 items, their addressed as 0, 1, 2, 3, 4. As you can see when I run this, there we go, 0 holds the value of 11, 12, and so forth. Here I'm using the for loop to explicitly address an individual element within my array and I'm having to do so using a positional notation. But what if I don't have a traditional array? Maybe I've got a collection of objects. Well foreach works on collections. So here, I'm going to use an array again, but an array you have to remember is a collection. So I'm going to load up the array and then I have my foreach constructs. Underneath it, you can see the script block is simply going to print out that item = $item. Here we have $item in $array. Well $array is the collection I'm going to work with. So $item is a variable that's going to hold the current value as it works through each item in the array. I've called it $item, nothing magical about that. I could have called it $fred if I wanted to. So let's Run this and you can see from the output, the first time through the loop the foreach took the value of 11, which was the first item and plugged it into the $item. Then the next time through, it puts the value of 12 into $item and so forth. The cool thing about foreach is because it works on an array objects it can also work on the output from various cmdlets. So here, I'm going to do a Clear-Host, and I'm going to set my current location to my Samples folder and then I'm going to do a foreach and I've named the variable $file and I'm going to use the Get-ChildItem cmdlets, which is going to return an array of ChildItems and I'm going to loop through each one of those and print out the name. So here, when I run this, you can see I get all the files in that particular folder. If I wanted to make this a bit spiffier, maybe I want to focus down and get just the ps1 items. Well that's where I can really start building upon what we've learned so far. Here, I'm going to use an if statement within the foreach. I'm going to use the -like comparison and then compare it against the wildcard of *. ps1 or some people call it an *. ps1, and if the name ends in ps1 only then will I actually print it out. So now, when I run this and we'll contrast it to what we have down below now, and my new output only has my ps1 files. Now, what if I'm in a loop and I want to get out of that loop? Well for that, I can use the break command. You may recognize the break command from the switch statement and it works somewhat similar in that it exits the current loop. So here, I'm going to have the same command I had before, but after it prints out that first file name, it's going to use the break. So let's come down here and Run this, and now you can see I only get one file name printed out that's because once it hit that first if statement and said, this is indeed a ps1 file, the break command exits the foreach and begins executing code at the very next line, it would be to this line right here where I'm putting at the f's. What if I don't want a break? What if actually want to do is skip over the rest of the loop, but go back to the next item in the loop? Here, I've got similar to what I had before, but instead of using the word break, I'm using continue. What's going to happen is when PowerShell hits this continue instead of executing anymore code left in the foreach loop such as this isn't a PowerShell file, it's instead going to move control back up here to the top of the foreach loop and then keep looping. When I Run this, you'll see what I mean, highlight that and there we go. For the ps1 files the code, This isn't a PowerShell file never executed and it only printed out the Get-ChildName. ps1 Module1. ps1 and so forth. For those items that were not ps1's it skipped over the if statement and instead printed this out. What happens if I'm using breaks or continues inside of a nested loop? We haven't really talked much about nested loops, but it's possible to have one loop occur inside of another loop. Here, I'm using a break inside the inner loop and what's going to happen is with a break it's going to return control back to the start of the parent loop. What actually happens is it hits the break, it's going to come down here to the next line, which is the squiggly brace that says go back up here and it's going to execute this again. So let's run this and I think it'll make it a little clearer what happens. Now here you can see the outer loop we've executed 1, 2, 3, but the inner loop we only executed once beginning with 4 because we hit the break statement each time. Also notice, this little piece of clever coding down here, if I get to, where I have 1.. 3 and down here I have 4.. 6, if you recall from an earlier video, I can use a range notation, such as 4.. 6 and what that does is it returns a collection or a range of values. So in this case, it simply evaluates 4.. 6 and says, oh you must want a collection of numbers in the range of 4-6. So that's why were we able to work this inside the foreach loop which required a collection. Now let's go down here because what I want to show you here is that you can use labels to break to a certain point in the loop. Here you can see I'm using a break command, but after the break I've put the outsideloop label. Up here, I'm using a : to indicate that this is a label designator, so let's Run this and you can see what's going to happen. In this case, we broke, but unlike before when we were able to execute the all 1, 2, and 3 from the outsideloop, because it broke we said we'll break to the outsideloop and it said oh, in this case I want to now break out of this loop and come down here to the line afterwards. Likewise and I can use continue with my inner loops and continue will work somewhat similar to the break except it doesn't return control back to the parent it just goes to the top of the current loop. So now, when I run this you can see I actually get outside 1, 4, 5, 6, 2, 4, 5, 6, and 3, 4, 5, 6. Because the only thing the continue did was skipped over the line that says This will never execute, which is this line right there. I can also use labels with continue. Here you can see I've used outsideloop again and now the behavior winds up being a little closer to what you saw with the break. Here, it only runs the for because it continued back to the parent loop and notice when it continued back to the parent loop, this line down here that was after the foreach, will never execute because at this point I'm jumping control all the way back up to here. So you've had a chance now to look over the various kinds of looping we have inside of PowerShell. I want to caution you to be real careful using the break and continue keywords. Break and continue can be the cause of many ILLOGIC errors within your applications. So use them sparingly and always see if you can find an alternate way of doing thing before you wind up resorting to break and continue.

Script Blocks
In our previous discussion on looping, I mentioned that what a loop actually executes is a script block. A script block is defined by curly braces. So here, within the curly braces is a script block. It's time now to look at script blocks and how you can use them within your own PowerShell programming. Here, I have a simple should be with two commands, Clear-Host and to print out the static text, PowerShell and bowties are cool. It's script block because it's defined within curly braces. Also note that because I have multiple commands on the name line I had to separate them with a ;. If however I were to highlight this and try to Run it, nothing really happens, it doesn't clear the host and it doesn't really print out my command. That's because when I execute it, it only shows the contents of the block it doesn't actually run the code inside it. Another thing I can do with script blocks is assign them to variables. Here I'm going to take that same script block and assign it to the variable, $cool. Again, all it does is assign it, it's not actually executing anything. If I were to just simply run $cool, again it just prints out what's in there, which in this case is the contents of the script block, it doesn't actually do anything. So I'm sure that by this point you're probably yelling at your monitor, YEAH, BUT HOW DO I ACTUALLY EXECUTE IT? Well to do that you actually use an & in front of the variable. So here, I have &$cool and now it is has actually cleared the screen and then executed the command to print out PowerShell and bowties are cool. It also works on an actual script block; it doesn't actually have to be inside of a variable. Here I'm clearing the host and then followed by a command to print out text so when I Run this we can see it's cleared the screen and print it out our Fez hats are pretty cool too. Now because scripts can be put into variables, we can do some interesting things. Here I'm doing a couple of things. First, I'm assigning a simple script block that will print out some text and then I'm copying the contents of coolwall into my subzerowall. Now in essence, that actually copied over everything in that script block into my second variable. So now, I'm going to enter a loop, I'm going to execute the loop three times and each time I'm going to execute the code inside my variables. Now this will actually have the affect of printing out my text six times, which is what you can see what happened. Now if I want to return a value from a script, I have to output it in a way that nothing else consumes that variable before the script ends. Here, I have a very simple script task that adds the value of 1 to 41. So I'm going to assign it to a value and then I'm execute and it prints me out 42. Now I can actually have this script block execute and return its value so I can do something else with it. To do so, I have to enclose it within parentheses. So here, you can see I have 1+ and then inside parentheses my & to actually execute a script block and then the script block itself which is contained in $ value and you can see here it returns 43 and remember if I don't put it in parentheses, I get a big red error message within my PowerShell environment. Now, here I have multiple commands within my script block and remember a second ago, I said it returns the first value that is not consumed. So what's going to happen is it's going to first hit 42 and then it's going to write out the host because 42 is not consumed it's got to return that to the screen. So here, I actually return 42 because it's not consumed and then I execute my Write-Host command. Now down here, I'm actually going to do something with that 42 and I want to add it to the number 1. So now what's going to happen, it's going to return the value of 42, it's going to execute my Write-Host command to print PowerShell iscool to the screen and then it's going to take that value I returned of 42 and it's going to take it into the rest of my equation add 1 to it and give me the result 43. This next example may make it a little clearer. Here, I'm going to take the output of my script task inside value and I'm going to place it in the variable 42. So when I run this, you can see it does display Pluralsight is cool and it took that first value that was not consumed 42 and placed it into my $fortytwo variable and I can actually prove that by printing it out. There's another command that works well with script tasks and that is the return command. Here I can actually return a value. Note though that when I use the return command, it actually stops the rest of script block from executing and returns control to the calling area. So here, when I execute this you can see it returns 42, but it never does the Write-Host command. That's because the return command said stop running the code, return whatever I've got here, and get out Down here if I use return by itself no value is returned because it stops the script executing and boom it doesn't print out anything. It is possible to pass parameters into our script blocks. There's actually two methods to this. In the first method we something called the arguments collection or args. This may familiar to you if you've done some C programming before, but if not, it's pretty simple. All of the arguments that you pass into your script block are placed into an array. So here, I'm assigning what is in the first position of my arguments array to the question and then assigning what's in the second place, position 1, to the answer. I then take that and write it out to the screen. So here, I'm going to assign qa and now my script block is assigned and now when I execute it, and I have two items passed in, it correctly returns the formatted text. Note too that since my parameter has spaces in it, I had to enclose those parameters within double quote marks. You would need to do this kind of thing for say text or if you're passing a path to a file into a parameter and that particular path had spaces in it. There's a second way we can pass parameters and it's a slightly more readable method where we use the param command. Here, I've told my PowerShell script, okay, I'm defining a couple of parameters, the first one's called question the second one's called answer. Now, when I take all this script and execute it, you can see I get pretty much the same results as before. So you may ask yourself, well what's the difference and why should I use one over the other? Well, the second method the parameters are a lot more clear. They're also named so we can use those to our advantage in a moment. The main reason you would want to use the first method is because you can have a variable number of arguments each time. You can query the count property of the $args variable to find out exactly how many parameters are being passed in and then execute the code within your script block for each one of those items, say in a for loop for example. So to sum it up, in cases where you need a variable number of arguments to a script block, use the $args. For the rest of the time, I would encourage you to use the param command. Now not only does it make it clear because we actually have explicit named items, but there are some more things we can do with it. For example, I can actually pass my parameters by name. Here you can see I place a - and then the name of the parameter and this is the same thing we defined in the variable params except without the $. So here we have -question What else is cool? And we have the answer and you can see that code executed. Now the nice thing about name parameter is I don't have to get the order correct. Here, I'm going to put the answer first, then the question. Another nifty thing is I don't have to give it the full name of the parameter. I can only pass in enough of the parameter name to make it clear which one I'm talking about. Here, my two parameters start with completely different letters so I can just put -a and -query and there we go, that worked just fine. Now what happens when a value is not passed? Well if I pass in question and not the answer, you can see it just essentially acts like I pass nothing or a null into this. Now, I can also check to see if a value is missing. So here within my script block I can actually use the!, what some people refer to as a bang symbol, and I can say if not answer, then I supply the value for $answer of, Error you must give an answer. So when I execute this and watch it run a command, and now it's actually detected that I passed nothing in for my answer and it's giving me an error message. If I wanted to be able to handle this, but not have an error of some kind, I could actually supply a default value for my answer. To do that within the syntax of the param command, I simply have an = sign after the name of the parameter and then I place the default value. So here I have $answer = the question has no answer. When I run this, it's not substituted my default value for answer. It is possible on our parameters to use explicit typing. Here, I want to force my two variables, x and y to be integers. So I'm going to run this and you can see when I actually run my math variable and I pass in the values of 3 and 11, I get the value 33. Now down here, I'm going to try passing in a 3 and then a string of x and now we'll see that we have a big error because x is not actually an integer it's a string. It's possible to make script tasks that you can put in line with our pipelines. This is going to make them extremely powerful and versatile because pipelines are one of the fundamental foundations of PowerShell. So here, I'm going to going to set the location to my samples directory and then I have a script task called onlyCoolFiles. To pipeline enable it, I need to use a process keyword and then I have another script block after process that says what I'm supposed to do. This is very simply as I'm going to look for the name property of whatever's coming in and I want to see if it's like *. ps1 and if so I'm going to return it's name. You'll notice I'm using a $ and then an _. This is a special variable that PowerShell has for the current object. It's not unlike when we used a foreach block and we had to supply a default name for the current object, same thing except this is one that PowerShell has built in for you. So let's assign this and now let's come here and we're going to clear the host and then we're get use the Get-ChildItem cmdlet and we're going to pass its output through the pipeline into our script block and there we go we're displaying only our ps1 files. There are times when I want to have code that executes before or after the pipelining processing code. To do that, we have a couple of more commands we can use. There's a begin command and an end command. The begin of course will take whatever is in that begin script block, run it first, then for each item in the pipeline it's going to do the process and then at the very end of it, it will execute whatever is in the end script area. So let's assign this to what's in my onlyCoolFiles variable. Run it and now I'm going to run that code and here you can see it's printed out some text of Here are some cool files which you can see right here. It's printed that out at the beginning and then it's executed all of the code and at the very end, it returns all of that in one big block. Now let's say I wanted to have the message be something of a variable. Well, I can combine some of our earlier techniques and I can combine pipelining with parameters. Here, I've declared a parameter called headertext and now in my begin block I'm actually using headertext instead of my static string, so now I'm going to load this into my variable and we'll come down here, we'll Clear-Host and you can see in this first example, I'm passing in my Here is my cool header text, but on my second example, I'm passing in a different headertext and there we go. Pretty cool stuff.

Variable Scope.
Now that we've had a chance to look at script blocks, it's time to fall back again with variables and talk about variable scope. Variable scope simply means how do variable react with each other both inside and outside of a script block? The first thing to know is any variable declared outside of a script block is available inside of a script block. So here I'm assigning the value of 42 to my $var variable. As you can see, that variable is the same when I access it inside the script block and outside. But what if try to change the variable inside of the script block? What would happen then? Well if I try to change is PowerShell will make a Copy of that variable and it will then work with that copy for the rest of my script block. So here, within my script block I've assigned of 33 in my variable. So now when I run this, you'll see that inside the script block it now has the new value of 33, but when I come back outside the script block it still has the original value of 42. Now this may seem a little odd at first, but it actually has great benefits. Often times, the people who write script blocks are not the same people that actually use those script blocks. So what this means is, you as the writer of a script block, can use variables and not worry about what variables the people who are going to consume your script block have created. In this case, if both of you had used the same $var, then you might be in trouble if PowerShell used something other than the behavior you've just seen. So now that you've seen it is safe to use any variable name you want, what then if you want to actually interact the variables outside of your script blocks? Well, if you recall from an earlier discussion, we mentioned the Get-Variable cmdlet and that Get-Variable was simply a substitute for displaying what the value of a variable is and if it's pretty much the same as displaying only the value. So here, if I were to just put $var on the screen it would be the equivalent of calling Get-Variable var- valueOnly and there we go, we get 42. Now a Set-Variable as you recall is a shortcut for saying $var=. So here, you can see when I assign the value to 99 it's the same as saying $var=99 and we'll prove that by using the Get-Variable on that. Let me Clear the display. Now the cool thing about Get and Set-Variable is they support scope as a parameter. The default 0 is the current scope with 1 being the parent, 2 the grandparent and so on. Using scope, we're going to be able to see both the local copy and the parent copy of the variable. So here, I have $var = 42 and then inside I'm going to assign a different value to $var. Now what's going to happen is it's going to create a local copy of var and put 33 in it. The next line, the Write-Host, will display the variable as it exists inside the script block, but to get to the parent, I have to use Get-Variable var and then I pass in -scope and I use 1 to get the parent variable. So when I run this, you can see that inside the block I get 33, then for my parent I get the correct value of 42 and it's still 42 once I get outside the block. Using Set-Variable, I can actually override the default behavior of creating a local copy and I can actually assign a new value to it. So here, you can see my $var is going to get 42 assigned to it outside the script block, then once I'm inside, I'm going to use Set-Variable to assign the value of 33 only when I access in the -scope, so it knows it's the parent version of this I'm talking about and then I'm going to print it out both inside and outside the block and there we go. I want to stress though that just because you can do this doesn't mean you should. This is generally considered bad practice. What you really should do is if you want to change the value is have it returned from the script block and let the consumer of your particular script block figure out how they actually want to use it. When you go changing parent variables like this, it can cause some very undesirable side effects. Now in addition to using Get or Set-Variable cmdlets with scope, I can also declare something to be of a global or a private scope. With a global scope, I can tell it, I want you to access this same variable no matter where it comes from. So here, I'm going to create a global variable of 42 and then within my script block I can access that same value. When I come out of that script block, it will now have changed and there we go, outside the block it now has the value 33. I can also create a variable that's private. In a private variable, I can only see it in the current context, I can't even see it with any script blocks I create. So here when I attempt to write out my unmentionables variable, it's going to not print anything because it's null. Outside the block however, I can still get to it. I can actually check for this inside the script by looking to see if it's = to null. It's going to tell you that it can't show you it's unmentionables because it's null, then outside the block it's got the value of 42. One last thing to note, if you declare a variable inside the block it's only accessible inside that script block. Once you exit the script block PowerShell throws that variable away. So here I've create a variable called localboy and when I run this, inside the block it retains that value, but once it gets outside the block I has thrown localboy away and it's going to be null.

Summary
We started this video learning how to branch our logic that is execute a set of code based on come condition. Next we saw how to repeat a block of code a certain number of times. After that, we learned about the power of script blocks. Finally, we learned how variables work inside and outside of script blocks. We covered a lot in this module, but we're just getting started. In the next module, we'll go into the more advanced topics of PowerShell programming including adding help and creating reusable functions to name a few of the items. Thanks for watching.

PowerShell Advanced Programming
Introduction and Functions
Hi, my name is Robert Cain and welcome to Advanced PowerShell Programming. In the previous lesson we covered the basics of PowerShell Programming. in this video, we'll dive even deeper getting to the more advanced features of PowerShell development. We'll start by creating our own functions, which connect as our own version of custom cmdlets. We'll see how to add help to our functions, as well as how to handle errors. Next, we'll look at how to work with the various file types in PowerShell. Finally, we'll wrap things up with how to handle user interactions in PowerShell. Beyond script blocks, we have functions. A function is essentially a script block with a name. There is one other important difference in that to pass parameters into a function we actually place those parameters in parentheses after the function name instead of using the param keyword. Here I've got an extremely simple function called Get-Fullname. Note that I've used the verb/noun syntax traditional of a cmdlet. For the two parameters I have firstName and lastName and the function simply prints them to the screen putting a space in between them. I can create the function by simply executing and now I can call it by simply putting the name of the function with my parameters and there we go, I've put it on the screen. Now unlike other languages, you'll note that I don't have to use parentheses when I call it or even commas, I simply use a space between each one of my parameters. If I have a situation where I want to actually effect the value of a parameter that's getting passed in, I actually have to use the reference designator. Here, I'm going to use the bracket ref in front of the name of the parameter, which is going to be an indicator that I actually want the function to pass the calling variable and not work with the local copy. Note too that by using the ref command it actually turns it into about object hence we have to use the. value syntax and when I get the function created I'm then going to assign the value or 42 to my function variable and I'm going to print it out. I'm then going to call the function and I also have to add ref to the function call here. Note too, I'm also having to enclose it in parentheses so that PowerShell won't confuse j bracket ref with a second parameter. Then finally, I'll print out its new changed variable afterward and you can see here it did indeed work to effect the parent variable that was passed in and not a local copy. It's also possible and even desirable to have functions work with the pipeline. You can see here the syntax is pretty much identical to what we used with script blocks. We have the begin, in which case we're going to display something before the process begins. Within the process, we're going to loop through each item that's brought in for the pipeline and at the end we'll do something. So let's create the function and it's now created and now let's call it and I'm going to take what is in Get-ChildItem and pass it to my getCoolFiles function that I just created and here we go it displays it on the screen. Now while the above works quite nicely it does tire function 2 only work with. ps1 files. We can actually create an alternative to functions called filters. A filter works something like the Where-Object cmdlet. The filter takes what is passed through the pipeline and looks for something specific within the object set that's coming in and only returns certain objects based upon whatever code you have in the filter. So here, I've got a filter called Show-PS1Files. I then set a local variable of filename to the current objects. name property. I then compare my filename to see if it's a ps1 file and if so, I return that object. So let's run the filter and I've now created it and we'll come down here so we can actually use it, and we'll Clear the Host and you're going to see that we're going to use Get-ChildItem with our Show-PS1Files. Now note, this isn't calling our function, so we're actually simply taking what was in Get-ChildItem, passing it through our custom filter to remove anything that wasn't a ps1 file. Here, I've got another function called List-FileNames. Now List-FileNames takes whatever's coming in through the stream and simply displays it on the screen. Note though that unlike the Get-ChildName function, this one doesn't do any checking for any kind of ps1 name, it simply takes whatever the objects coming in are and displays the. name property to the screen. So let's create our function and now when I pass Get-ChildItem into List-FileNames it returns just the names for all my files. Now, I can combine both my filter and my function into the pipeline to give me some really good flexibility. Here, Get-ChildItem returns all of the files in my current folder, as objects. It then pipes that through Show-PS1Files to remove those files that are not *. ps1. I then pass that list of objects into List-FileNames, which then iterates over that list of objects and displays the. Name property for each object. Now where this starts becoming really useful is when I start creating other filters to work with it. Here I want to create a filter for just my. txt files. So little highlight this and Run it and now I have second filter called Show-TxtFiles. When I put it, instead of the Show-PS1Files, you can see it only shows me my text files. Now, I have two different ways that I can use my same function. We'll clear the screen, and we'll do both Show-PS1Files and Show-TxtFiles, and there we go. Down at the bottom, you can see it first listed my ps1 files, then my text files. So whenever you can, think about breaking things down into the smallest possible unit of work and then you can use filters and other functions to combine their power together to create really useful flexible cmdlets that you can use if in your programming. Now, just like my function can consume pipeline objects, it can also output to pipeline. To do so, it's a simple matter of using the Write-Output. So here, I'm going to create a simple function called Get-ChildName and what I want it to do is have the equivalence of doing Get-ChildItem with Select-Object Name. So let's clear the host and this is the actual output that I want to see when I'm done, is just a listing of all the file names, but let's create a function and now if I just want to call Get-ChildName, you can see I have the same output as earlier. But now I can take what is in Get-ChildName and takes its output, pipe it through Where-Object, and now I only get my ps1 files. So sending things out the pipeline is just a simple matter of using the Write-Output. One last thing to show you on functions. When we were discussing cmdlets early on in this series, you saw that many of the supported various switches. Some of the most useful being the -verbose and the -debug. Well, it's possible to support these within your own functions. To do so, you need to know that PowerShell has a handful of special built in preference variables. The main two we're concerned about is $DebugPrefence and $VerbosPreference. Now when these are set to their defaults of SilentlyContinue, anything that uses the command to display things to the debug or to the verbose streams are essentially ignored. If we want them displayed, we have to change their values to continue. So here, within my function, I have two special parameters setup. I've designated these to be switches, which means I'm not actually looking for a variable to passed in. With a switch I'm looking for a - and then the work verbose or a - and then the work debug. Within the context of my function, these are actually labeled as $verbose and $debug, but they're not going to have any data in them. Also note that here, I'm using the words verbose and debug, but I could create my own custom switches if I wanted to, all I would have to do is use my own name in lieu of verbose or debug. So here with the param, what I need to do first is check to see if that switch was used. If $verbose. IsPresent is true then I want to change my VerbosePreference switch to Continue, otherwise I want to make sure it's set to SilentlyContinue, the same thing for debug. I then use the Write-Verbose to display extra verbose information to the display. I then have my Write-Debug to display other information to the debug stream. So let's Run this, there we go, and now I have my function called three times. The first time I call it, I'm going to call it without any switches and you can see it's displayed things on the bottom, but it hasn't displayed any of my extra text. If I scroll back up, you can see there's nothing extra there. Now if I use the -verbose switch, and I scroll up, you're going to see in big blue text it put, Current working location is and it has my current working location. If I call it using the debug switch, you can just see it display the debug at the bottom, but it's lacking the verbose at the top. Finally, I can put in both switches to get both my debug and my verbose text.

Custom help
One of the wonderful things about PowerShell is the rich help that is provided with each cmdlet. It's possible to add help to your own functions that you write and fairly easily. By default, PowerShell doesn't give a lot of help when you create a function. Here, I'm going to call Get-Help on my Get-ChildName function that I created previously in this series. When I run this, all it really shows me is that I support two switches -verbose and -debug. Creating help though is as easy as putting comments into my function. All I have to do is to create a comment block. Within that comment block, I then use special tags that PowerShell has established and that its Get-Help function will understand. These tags all begin with a., so here you can see I've got. SYNOPSIS,. DESCRIPTION,. PARAMETER name and these are pretty self explanatory. Note that I don't have to use each one of these within my help system, I could choose to just simple and only use. SYNOPSIS, so I just get a brief description of the command. Note that,. LINK may be a link to a URL for more help. If I want to learn more, you can go to Get-Help about_comment_based_help for a full list and all the detials that are associated with writing help. Now let's look at a simple example. Here, I've got my function name and the first thing I do, after I create the block, is I put a left arrow and then the pound sign. This is the opening tag for my comment block. I then have my. SYNOPSIS followed the synopsis itself. I then have the DESCRIPTION and the description and so forth. I have my EXAMPLES, my LINK, and then I close out my block and then finally I actually have the syntax itself that's going to be executed when I call this function. Now you can see here that for my simple functions, often times the help will wind up taking up more space than command the function itself executes. So let's run this and we recreate our function and now our function has the help in it. We'll clear the screen and then we're actually going to call Get-Help on our function and now you can see, we actually have some nicely detailed help on our function. There's the NAME of the function, its SYNOPSIS, the SYNTAX and more. If I want to see more information, I can come down here and I can use the Get-Help full switch and now, in addition to the other text I also have all of my examples. Writing-Help can be pretty simple, straightforward, and quite useful. I highly encourage you to put help into all of your functions, especially if it's going to be ones that you're going to want to share with your friends and coworkers.

Handling errors
Let's face it, no matter how wonderful your PowerShell program is at some point something's going to go wrong. To help you handle those situations, PowerShell has some really extensive error handling capabilities built into it. As a matter of fact, they're so extensive there's no way we could cover them all in this little short segment. But we are going to show you the very basic of error handling capabilities and it's enough to get you up and running and have the ability to recover from errors within your applications. Let's take a look at this little simple function called Divver and all it does is it divides an enumerator by the denominator and it displays us some debugging information to let us know that when it begins, when it ends, and what the result is. So let's highlight this and run it and we've got it as a function now and let's run it and we're going to take 33 and divide it by 11 and it's going to give use the result of 3. So now let's come down here and actually do something that going to cause an error. We're going to take 33 and divide by 0 and now we get this really ugly error message, Attempted to divide by zero and it gives us all this error text and then it comes out and still tries to keep running by showing us our result and the fact that it's done. Well, we'd like to be able to handle this internally within our particular function. So for that situation, we have a function called Trap. Now if I come down here you're going to see the trap code followed by a script block. So here, if an error of any type occurs within my function, it jumps down here to the trap and executes what's in the script block, in which case I simply write Oh NO! An error has occurred! I then access the generic variable of $_ and I retrieve the ErrorID and display it in the Exception_Message. I then use the Continue keyword. Now you may recognize this from our looping segment, but it works just slightly different. Here, continue doesn't execute the particular script were in, here continue goes onto the next line of code after the line that generated the error. So when I compile this, let's come up here and we'll run it. It gets us function created and now when I run it, it tells me that I had an error, Attempted to divide by zero, but then it went on and ran the rest of my function. So what if that wasn't a functionality that we wanted? We wanted maybe to break out of the function and quit running. Well to handle that, we have an alternate keyword of brake. What a break will do is stop the function from running and go back up the parent function. Now what it also does is it bubbles that error up to the parent. So let's come up here and we'll compile this and run it, there we go, and let's cause the error to occur and now we our error message, Attempted to divide by zero and Oh NO! An error has occurred, but PowerShell still throws out that really ugly error message to us. Another thing we can do is actually check for this specific error message. So here, I'm going to add an extra trap statement and you'll also notice that I've moved the traps from the bottom of the function to the top. This is just to demonstrate that you can place these trap statements in here, anywhere within the function. I could have even mixed them up with the individual lines of code, although it would really be pretty ugly and hard to read. What I advise you to is to pick a place, either the top of the function or the bottom of the function, put your trap statements there and then be consistent about it in all the functions you write. So here, in my trap, I'm going to check for a specific error with the first trap, System. DivideByZeroException. Now if that looks familiar, it's a. NET exception. Remember, PowerShell is a nice layer upon. NET, so anytime you need to look for a specific error, go reference your. NET error types and that's what you're going to be looking for here after the trap keyword. So now, if I find a System. DivideByZeroException, I'm going to display, Hey, chowderhead, you can't divide by zero! and then I'm going to continue, otherwise, I'm going to display whatever my generic message is and with a break command and yes you can mix these up, so some of these traps use continue and some of them use break. So let's highlight all this and get it to run and now, it correctly displays, you can't divide by zero. It doesn't display any of the custom error message and we can continue on with our program. There's two main ways you're going to want to handle errors and the first way, we're going to handle the error internally, which we've just done in that function, so that function you saw just now illustrated that. In the second way, we'd have to add trap logic within our parent that called that particular function. So we're going to do the same function again, the only difference is going to be that in our custom error, System. DivideByZeroException, we've change the continue to a break. So let's come down here and get this to actually run. Now, I've created a little script block within my script block at the bottom I have a trap and then I just have the keyword continue so that my parent script will continue silently. So let's come up here and we'll execute this script block. So here we go. We go the results we wanted. We got the function to stop executing and return control back to the parent. Within the parent, we call the function and we silently suppress the errors by simply using a continue. The downside to this method is you wind up with a lot of these little script blocks within your overall PowerShell script application in order to trap and silently continue on these errors. There's no great way to handle this. Of course, the best way would have been within our function to simply check to see if the denominator was 0 and trap for that illegal input given the error message and not ever hit the trap routines, but in those situations where you can't do that, know that you can use trap and you can use it either to look for a generic error or that you can use it to look for specific. NET errors.

Working with files
We've done a lot with PowerShell so far, but one thing we really haven't touched on much is working with files. That's one of the more common thing you're going to do in any PowerShell environment, so let's take a quick look at how to work with files. Now you may have noticed that some of the directory listings that I've done, that I've had a series file, that had a single letter along with the. txt extension. These files actually contains the names of some of the courses that Pluralsight offers on their website, each file being from a different author. Let's look at one of them now. To retrieve the contents of a file, we use Get-Content and then we simply pass it the file name and we can see here it lists all the items that are in that file and hey, these just so happen to be courses that I did. Now if I want to, I can actually assign the contents of a file to a variable. So there I've assigned the contents to the $a variable and if I print it out, you can see I get the list of items. Now, it may look like everything's in one big string, but looks are deceptive. This is actually an array. Here, I can actually use my array syntax to get the first element, which is element 0. I can say get the 3 one for example and I can prove this because if I come here and I use GetType, it shows me that it is an object and the bracket syntax indicates that is indeed a system. array base type. I can actually iterate over every single one of these and print them out. Now a lot of that times, you may actually want to do what I just did, iterate over every single line that came in from the file and do something with it. There are times though, when that may not be the results you wish. You may want to work with everything as one bug object. So to do this, we can combine everything together using the static Join function off the of string class. Now the Join function requires two parameters. The second parameter is of course the file that we want to join together. The first however, is a separator that's used to separate each line so that it knows how to join them. To get the separator we're just going to use the System. Environment NewLine to retrieve that new line and place it into the separator variable. Now we know because this is a Windows based file, we could have also used the `r `n. You might also know that if you're pulling the file, maybe it came from the Unix system or something, it may only have either `r or `n as the separator. So here, let's do this, let's join everything together and we'll print it all out. Now it looks like it did before, but this time if I use GetType on all, it tells me it's string and not an array. The cool thing about Get-Content is it supports wildcards. So if you remember, I actually had five different files with course names in it, so by using the?, I actually can combine all of these files together at once and there it is. It's actually loaded me a whole list of things, in addition to my courses, there's courses by various other Pluralsight authors. There we go and of course, like before, I can use the Join syntax to join them all together. Get-Content is used to get contents off the disk, so we'll use Set-Content to put that data to the disk,. Now just to prove that data is not there, I want to write everything out to an allcourses. txt file and this should return an error because Get-ChildItem shouldn't be there and sure enough it does, I get a nice big error because that file does not exist. So let's actually write it out now and you'll see Set-Content requires two things. It first requires a value parameter in which case we take the text that we want to put out there and pass it in as a variable and then we can use the -path, to indicate what the file we want to put it to is and there we go. Now, we can use Get-Content and there's all of our data. Now be aware, Set-Content is destructive. If I want to add this new PowerShell course you're viewing now to this list, and I set it out there using Set-Content and then I do a read from that, you can see only the PowerShell classes in there now. It has wiped out what we had before. If we want to append, we need to use the Add-Content cmdlet. So let me first reset this to put everything back out there and now, we can use the Add-Content to add our new course and there it is, it's put out there. Now we're going to cleanup afterward and we're just going to use Remove-Item to get rid of that file because we don't it anymore and that was working with text files, but we're not limited to that. We can also work with comma separated value files. Let's first use it to save data out to a CSV file using the Export-Csv cmdlet. The command we're going to use to pipe into that is Get-Process. Get-Process simply lists all the processes that are currently running on the machine, as you see there. So now, I'm going to Run this and it's going to populate the Processes. csv file and let's go open that up and you can see that it is indeed a csv file, there it is right there and we're going to open it up in Excel and there it is. There's all of the data that was in the process and you can see Excel properly lined it up into the various columns that it needed. We can actually read things back in. To do so, we provide a header and I actually just Copy this header out of the CSV file and then we use the Import-Csv. Import-Csv requires two things, the name of the file and then it requires a header so it knows how to break things up. When I actually execute this code and display the processes, you can see that it's listed all the processes and in this case, it was too big to support it in a wide format, so it actually took it and placed it into a more of a tabular type format. So let's come down here and the next thing we're going to look at is XML files. XML files become very, very popular almost the defacto standard of doing data interchange these day. So next we're going to look at how to actually create an XML file. We're going to start by creating an XML template and this XML template is just extremely simple. I have a courses and it's going to hold a list of the Pluralsight courses that are out there in those five individual text files. We create out course template by using a here string and I just have my overall courses, then I have each individual course and each individual course has a name and a level and when I have that course template, I'm going to write it out to PluralsightCoruses. xml. So let me execute this. Now I'm going to load that file I just created into a courseXml file and I'm declaring this way so that I can actually force PowerShell to make this in XML type variable. So let's do that and then on the second line, we're going to use the. load method to actually load that data in there into the courseXml variable and that's taken care of. Now, the only thing in my XML file is the template I just created. What I want to do is I want to grab a clone of that template and put it into a variable so that I can work with an individual item, within my courses collection and that's what this syntax here will do. The -0 will grab the first item in the collection and then it clones it and puts it into this newCourse variable. Now the next thing I have is some syntax to import a comma separated value that has a list of all my courses. Now if I come back here you can see I've got an All Courses. csv file and if I open that up in Excel you can see I have two columns, my course name and the course level. The next thing I'm going to do is import these. Now that's they're imported into my coursecsv variable, the next thing I want to do is iterate over all of those items. So I've got a simple for loop that's going to go from 0 to number of items. It's going to first take a clone of that newCoruse variable to create a new Copy of it. Then it's going to assign the name from the course of the CSV, it's going to then assign the level, and then finally, it's going to take this new child called newCourse and it's going to append it to the existing course an XML collection. Now at the end of that line, I've got a > which redirects that output into the $null. If I don't do that, it's going to echo each one of these children as I append them to screen, which is probably not a desirable outcome for most scripts. So we'll run that and now, we have the file loaded, but we also still have that template out there in the file. So what we want to do is get rid of that. So we're going to iterate over our collection of courses where the name of the course is blank and for each one of those, we're going to remove it from our collection, run that. Finally, we can everything out to our file. Alright, let's make sure everything's out there. First thing we're going to do is open it up as a straight text file and display that and here were go. Here is our XML file and I'm simply displaying it as text. Most of the time, when you've got an XML file, working with it as text is kind of boring. What we actually want to do is work with it as XML. So to do that, we'll come down here and we're going to create a new variable and this time I can actually force it to be an XML variable by using the bracket XML in front of it. and I'm loading it at the same time from my file using Get-Content. Now that it's loaded, I can use a foreach to iterate over each course in the courses collection and display its information to the screen and there we go, three different ways to work with three different file types within PowerShell.

Putting it all together.
I like to refer to this final section as putting it all together. Here, we're going to use many of the techniques we've learned throughout this video series in our final demonstration and we'll learn a few new things as well. Most of the time, when you're doing your PowerShell script execution, you're going to be doing so through a PowerShell window such as this one. Your interactions will be primary text based and it'll simply be executing a particular script that we'll go off and do things. There are time however, when you need to do some interfacing with the users. For that, we'll need to know a few things about how to actually interact with the users and get information from them. Let's take a look at a series of scripts I have setup that will help us do that. Let's start by maximizing our code window, and what we want to do is we want to display a menu for our users and get some feedback from them. We're going to have a title at the top of our user interface and that title is going to surrounded by a nice little box. We're going to display a menu and we're going to ask them to enter a choice. We're then going to interact with them displaying the choice they pick, asking for more feedback, and then ultimately saving that to a file. So, what you see here is the code necessary to accomplish that. To help me out, I've create a few special little helper functions. Down here you can see one of them, Set-AppColors, another one is Display-AppHeader, and then down towards the bottom I have one called Write-TxtFile. Now I'm sure you've probably thought by now, after watching our series on functions, that having to Cut and Paste our functions from one module to another is extremely inefficient. We should be able to create a library of functions that we can reuse in our various PowerShell scripts and that is indeed the case. We can use this command up here called Import-Module. We can import as many modules as we need and each module can have whatever amount of code it needs and those modules could also have imports into them. Here, I've kept it pretty simple, let's take a look at the functions. I first have a function called Set-AppColors. What we want to do is we want to change the colors for our user interface to make it look spiffy. We'll have a black background and a green foreground. We're also going to change the title of our window to Putting It All Together. Now, when you're dealing with PowerShell, it's important to know what environment you're running in because the commands to change those colors are somewhat different. if you are running within the PowerShell Integrated Shell Environment or ISE, there will be a special variable called $psise through which you can access several options of the environment. If you're running in a command window however, that variable will be null. So down here, you can see I compare to null and if it is null, hey I must be running in a command window and thus I use this set of commands to change my background, foreground colors and the window title. Otherwise, I have little more flexibility and I can use these options to change my colors. I also get the ability with the ISE to use hexadecimal color codes, something I don't get with the command prompt. Next, have a little helper function called Get-WindowWidth. Get-WindowWidth is not used directly within my code, however it used by the subsequent function, Display-AppHeader. Get-WindowWidth is pretty straightforward, it checks to see where it's running. Now if it's running in the ISE, it will not have a max window size. Thus the max window size will be null and I had to force a number in there so I just picked 80. If I'm running in the command prompt, I actually can get a max window size, so I return that value to my window width. Next is the Display-AppHeader itself and it displays that title that is passed in, in the parameter. The first thing it does is it makes sure that there's a minimum length, it gets the window width, using the Get-WindowWidth function you just saw. It then does a little math to determine how long the title is, and then it creates a padding to put on either side of the title in order to center it. It also uses this nifty little feature of PowerShell. Here if I take a character such as a space and I use the multiplication symbol to multiply it by a number, it actually repeats that character however many times are indicated by the number. So here, I'm taking the width of the window, subtracting the length of the title, and then dividing that by 2, so I get equal number of spaces to either side of the title. I then repeat that little trick by multiplying a - times the window width to get my top and bottom bars that are going to frame my title. Next, I move down to the Write-Host. What the Write-Host will do is it will print an * and then it will put the padding, then the title, then some more padding, and then another *. I'm using the -NoNewline switch so that it does all of this on the same line. Additionally, I'm using a second switch called -ForegroundColor so that I can specify a different foreground color in this case White, for the title. Finally, I close at the function by printing my bottom border. The last function I created was called Write-TxtFile. What Write-TxtFile will do, it will take whatever is in contents and write it out to a file within the $path parameter. It also has support for the -verbose and -debug switches. Write-TxtFile actually has a little bit of extra functionality. If I scroll down you can see that one of the first things it does is it checks to see if the file ends with a. txt extension. If it doesn't it will append it for you. Now in order to get that to work, I wanted to be able to use the. ToLower and. EndsWith features of the string data type. However, when parameters are passed in, by default they come in as an object. So I had to create a localized string variable called $FileName and I had explicitly type it as a. NET string. This will allow me to call. ToLower or. EndsWith and if. txt was not present to add it on. Next, I use a feature called Test-Path to see if a version of a. bak file exists for this file. If so, it deletes it using the Remove-Item. It then checks to see if the file name I'm targeting exists. if so, it renames that to the. BAK file. Finally, it saves out the contents. So you can see there's a lot of nice functionality here that I might want to reuse over and over again. Let's jump back to our Putting it All Together and you can see what it's going to do is select a menu option, tell us that we think that choice is cool. It's going to ask what makes us think that? It's going to echo that back and ask us what file do we want to save it as. Let's actually execute this. Let me come back and put that, now I want you to pay attention because down here all these colors are about to change. We're going to actually execute this and it's going to ask us to Select a Menu Option and to do so within the ISE it pops up a dialog box. You can see down here it's printed out our title boarder and it's asked us to Pick something really cool and it's listed out five items. Here I'm going to type out a number, we'll say number 1 because Pluralsight's really cool, but notice that there's no type checking within here, I can type in whatever I want to. So we'll just say that number 1 and we'll click OK. Now it's going to come back and tell us, hey you thought number 1 was really cool! What makes us think that and we'll say something like Great Courses and we'll say OK and then it asks us to enter a file name we want save it to or we can click OK to just not save it. So I'm going to call this Demo. I'm going to omit the. txt extension and we'll click OK and now you can see the bar, which indicates that our script is now done executing. Let's come here and make sure our file actually exists. I'm going to use dir which is an aliases for Get-ChildItem and I'm going to pass in Demo* for the wildcard, and you can see that sure enough our Demo. txt actually exists. Also, notice that after our script got done executing, we were left with the same color scheme. We can also contrast that to what we get if we actually run this out of a script window. Here we go and I've got the colors on this window set to white on blue. To actually execute a script out of this window, we have to prefix by using. \ and then we can type in the name of the script. I can omit the. ps1 extension, when I hit Enter it clears the display and this time instead of having a pop-up dialog, it just places the cursor on a line and this time maybe I'll pick number 2. Oh, even better, let's pick number 5. In case you don't know what a Bugatti Veyron is, it's the world's fastest production car and has a top speed of 264 miles per hour, so we're going to click Enter and it asks us, Why it was cool? And we're going to say it's because it, goes really really REALLY fast, then I'm going to click Enter and it says Oh, that's a pretty good reason. Where do we want to Save it? So we're going to type in Demo again, hit Enter and now it's done. Now if I do another dir on Demo, whoops, I go ahead of myself I forgot to put eh * at the end, dir Demo*. There, there's our Demo. txt file. Now I want to point out something pretty important. If I come back over here and up here in our import line, this actually executes all of the code within this file. Now here, I only have functions, so it executed the function that will actually create the functions for us. If however, I had actual commands in here such as Remove-Item, Create-Item, these kinds of things, then those commands would also be executed outside the context of a function. Just be aware that those kinds of things can occur, but it could also be quite useful because you could actually create variables to hold things like maybe constants, or something like that, that the functions that you have in here need. Also, be aware that the functions only exist during the execution of the parent script. Up here I've got my, let's say the Set-AppColors and if I try to do a Get-Help here on Set-AppColors, I'm actually going to get the help because the ISE still understands that these functions exist and are within its memory space. But let's contrast that by coming down here and let's try to do a Get-Help here (typing). You can see I get an error because the Set-AppColors no longer exists in the memory of the console. So just, be aware that that kind of thing can happen and there are some differences to when executing code in the console versus executing code within the ISE. Now there's sometimes when you want to only execute code within the console. So to do that, you might want to create a little routine that prevents people from running things within the ISE. So to do that, I've just put together a very little simple function called Prevent-IseExecution and here all it really does is checks to see if that Integrated Shell Environment variable is null or not. If it's not null then it tells me it cannot run this script and it issues a break, which will then bubble up and stop my script from running. Otherwise, it continues on and says, I must not be in the ISE. When I run this, you can see I get my, You cannot run this script inside the PowerShell ISE. If I come back over here to this window, remember, we have to use the. \prevent-iseexecution, it actually said, hey I must not be in the ISE and it didn't give us the error message. So you should consider incorporating something like that into your scripts if you need that functionality. One of things that made this work really well is the piece of code here called Read-Host. Read-Host is what allowed us to display a prompt to the screen and return that choice to a variable. In this case, it first returned to $choice and down here to $reason. You also saw that Read-Host was implemented differently between the ISE and the command window. In the ISE it popped up that little dialog box, but in the command window it just put the cursor at the end of the prompt and waited for us to type something in. Be aware that different environments can handle these kind of things differently.

Summary
In this series, we've used either the PowerShell command window or the PowerShell ISE for all of our work. That's because their available with every installation of PowerShell 2. 0. Be aware though, that other PowerShell editors do exist. Two free ones you may want to look at PowerSe and PowerGUI. There are also several very nice PowerShell editors for sale. Because of the extreme simplicity of the Integrated Shell Environment, we're soon likely to migrate to another more fuller feature development environment. Even so, it's worth knowing about the Microsoft supplied ISE since you know it will be available on each box where PowerShell 2 exists. Phew! We finally made it to the end of our series on PowerShell! In this module, we dove deep into the real power of PowerShell programming by learning about functions. Beyond the basics of functions, we learned how to add help to them and manage errors. We also saw how to work with three different file types, as well as construct a user interface. Now that you have the skills to write your own PowerShell programs, I'd encourage you to begin looking at the many providers available for PowerShell. We touched on providers all the way back in Module 1 and it's through providers that your own PowerShell applications will be able to interact with the rest of the world. Thanks for watching.